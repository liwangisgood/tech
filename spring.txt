1、聊聊spring

2、说明bean的生命周期

3、循环依赖-->提前进行AOP
    1Aservice代理对象.target = Aservice普通对象
    2之前都说了，AOP产生的代理对象，不能放入单例池（一级缓存），所以才二级缓存。
    代理对象创建完后就存入代理对象中，
    3代理对象最重要的是执行切面逻辑,切面执行完后 会执行target对象的对应的普通方法
    4需要普通对象才能得到AOP代理对象的
    没有AOP的IOC的话，确实二级缓存就够了，有AOP的话如果提前发生AOP就需要再多一层缓存，大概这个意思吧
    
    0、creatingSet<'AService'> CreatingSet是几级缓存啊?    CreatingSet只是用来存放正在实例化的bean的名字，并不是缓存
    1、实例化-->Aservice普通对象-->singletonFactories.put('AService'，AService普通对象)
    2、填充bService--->单例池Map--->创建BService
        BService的Bean的生命周期
        2.1.实例化-->普通对象-->singletonFactories.put('AService',()-> getEarlyBeanReference(beanName，mbd，AService普通对象))出现循环依赖才会被用到
        2.2.填充aService--->单例池Map-->creatingSet-->Aervice出现了循环依赖-->earlySingletonObjects-->singletonFactories-->lambda-->执行lambda-->AOP-->AService代理对象-->earlySingletonObjects
        2.3.填充其他属性
        2.4.做一些其他的事情 (AOP)
        2.5.添加到单例池
        
    3、填充其他属性
    4、做一些其他的事情(AOP)-->AService代理对象
        earlySingletonObjects.get("AService")
    5、添加到单例池
    6、creatingSet.remove("AService")
    

4、三级缓存
    类DefaultSingletonBeanRegistry
    三级缓存
        第一级缓存:singletonObjects ConcurrentHashMap<String,Object>()
            保存bean完整生命周期的对象
        第二级缓存:earlySingletonObjects ConcurrentHashMap<String,Object>()
            应对可能出现的循环依赖，提前产生的代理对象保存到二级缓存中
        第三级缓存:singletonFactories HashMap<String,ObjectFactory>()
            创建某一bean过程中，创建lambda表达式保存到三级缓存中，源码中然后属性填充 初始化前  初始化 初始化后

5、FactoryBean和beanFactory

6、ApplicationContext和BeanFactory

7、设计模式


<bean id="" class=? scope init-method abstract>
<property name="" value="">
<property name="" ref="">
</bean>

<bean id="dataSource" class=? scope init-method abstract>
<constructor-arg name=? value=?>
<property name=username ref=${jdbc.username}>
</bean>
bean的定义信息xml 或 注解
抽象接口，定义读取配置文件的规范 BeanDefinitionReader
从BeanFactory体系获取，bean定义信息BeanDefinition
接口BeanFactoryPostProcessor完成${jdbc.username}值的替换，可以实现这个接口 获取和设置BeanDefinition
最终的BeanDefiniton对象
Abstract base class for property resource configurers that resolve placeholdersin bean definition property values. Implementations semspulls/em> values from dproperties file or other f@linkplain orgspringframework.core.env.Propertysourceproperty source} into bean definitions .
修改bean的定义信息需要实现BeanFactoryPostProcessor

实例化Bean
填充属性
BeanPostProcessor:before (1、增强器 2、后置处理器) aop(动态代理)
初始化bean
执行init方法
BeanPostProcessor:after   aop(动态代理)
完成bean对象

<property name=username ref=${jdbc.username}>实例化对象前属性值全部替换
创建对象
    实例化Bean：在堆中开辟一块空间，属性都是默认值
    初始化bean：给属性完成赋值操作(1、填充属性，赋值 2、调用具体的初始化方法3、扩展实现)

BeanFactory：用到反射实例化Bean...


BeanFactoryPostProcessor 子类 BeanDefinitonRegistryPostProcessor 子类 ConfigurationClassPostProcessor----->springboot自动装配原理
BeanPostProcessor（执行前置处理方法、执行初始化调用方法、执行后置处理方法）
AOP是IOC的一个扩展

new ClassPathXmlApplicationConext("applicationContext.xml")
底层通过反射创建容器对象

Environment接口为了方便使用，在容器创建的时候会提前加系统的相关属性加载到StandardEnvironment


refresh

BeanFactory 叫DefaultListableBeanFactory

beanFactory 被applicationContext继承
DefaultListableBeanFactory存放所有的bean



DefaultListableBeanFactory 属性值 beanDefinitionNames beanDefinitionMap(要创建的bean的信息)

循环依赖？
spring解决循环依赖问题、三级缓存(singletonObjects一级缓存 singletonFactories三级缓存 earlySingletonObjects二级缓存)、提前暴露对象
根本：实例化和初始化分开来操作
ObjectFactory 函数式接口 
getBean->doGetBean->createBean->doCreateBean->createBeanInstance->populateBeans
getBean到容器中查找是否已经创建过该对象


周瑜spring高级底层源码2022最新版
https://www.bilibili.com/video/BV1tR4y1F75R/?p=2&spm_id_from=pageDriver&vd_source=a624d5626dc0011dc56bfc4cc466feb4
手写模拟Spring-周瑜
    容器启动
    BeanDefinition扫描
    Bean的生命周期
    单例与多例Bean
    依赖注入
    AOP
    Aware回调
    初始化
    BeanPostProcessor
    
Spring底层原理-周瑜
    Bean生命周期
    推断构造方法
    依赖注入
    @PostConstrct
    初始化前
    初始化
    初始化后
    AOP
    Spring事务
    @Configuration
    循环依赖
    Spring整合Mybatis

spring自定义容器：
    puclic class XxxApplicationContext{
        Class confiClass
        ConcurrentHashMap<String,Beandefinition> beanDefinition
        ConcurrentHashMap<String,Object> singletonObjects
        ArrayList<BeanPostProcessor> beanPostProcessor
    }

  1、扫描--->BeanDefinition-->beanDefinitionMap
  2、实例化Bean createBean(String beanName,BeanDefinition beanDefinition)
    从beanDefinitionMap中获取beanDefinition
    单例bean:singletonObjects中有则返回，无则createBean(String beanName,BeanDefinition beanDefinition)
    多例bean:每次都会createBean(String beanName,BeanDefinition beanDefinition)
    为bean配置beanName,System.out.println(applicationContext.getBean("userService"))
        1、自定义@Component("userService")在类UserService，反射创建bean获取beanName值
        2、自定义@Component在类UserService，反射获取类名UserService,beanName=Introspector.decapitalize(clazz.getSimpleName());//类名改为小驼峰userService
    使的测试spring bean获取bean对象 并打印输出
    
    管理类中属性注入其他bean
        自定义@Autowired 实现依赖注入
            createBean(String beanName,BeanDefinition beanDefinition){} 反射.newInstance()实例化bean
            clazz.getDeclaredFields(){}//判断字段Field f是否有注解 f.isAnnotationPresent(Autowired.class)
            // 简单版依赖注入
            for(Field f:clazz.getDeclaredFields()){
                if(f.isAnnotationPresent(Autowired.class)){
                    f.setAccessible(true);
                    f.set(instance,getBean(f.getName()));
                }
            }
            // 属性填充的问题：
                // Aware回调 还有很多其他类型回调 思路差不多，如：applicationContext beanFactory 
                // 初始化InitializingBean 初始化后AOP(BeanPostProcessor)
            if(instance instanceof BeanNameAware){
                ((BeanNameAware)instance).setBeanName(beanName);
            }
    手写BeanPostProcessor接口,
        @Component//使之成为一个bean
        public class XxxxBeanPostProcessor implements BeanPostProcessor{
            @Override
            public void postProcessBeforeInitialization(String beanName,Object bean){
                //自定义代码
            }
            @Override
            public void postProcessAfterInitialization(String beanName,Object bean){
                //自定义代码
            }
        }
        
        具体使用为每一个创建的bean进行初始化操作
            // 扫描Component注解
            if(clazz.isAnnotationPresent(Component.class)){
                if(BeanPostprocessor.class.isAssignableFrom(clazz)){
                    BeanPostProcessor instance =(BeanPostProcessor)clazz.newInstance();
                    beanPostProcessorList.add(instance);
                }
            }
            for(BeanPostProcessor beanPostProcessor : beanPostProcessorList){
                beanPostprocessor.postProcessBeforeInitialiation(beanName,instane);
            }
            
            for(BeanPostProcessor beanPostProcessor : beanPostProcessorList){
                beanPostprocessor.postProcessAfterInitialiation(beanName,instane);
            }

    步骤：依赖注入->Aware回调->postProcessBeforeInitialization(beanName,instance)->初始化->postProcessAfterInitialization(beanName,instance)  
    jdk动态代理转换为的类型 接口类型，不能转换为实现类类型。
        如用postprocessorAfterInitialization(){
            //实现jdk动态代理接口,执行单个方法，方法前后可执行其他业务逻辑(aop功能
        }
    
idea项目out目录获取不包含包名：
ClassLoader classLoader=类名.class.getClassLoader();
path="com/zhouyu/service";//包名：com.zhouyu.service
URL resource=classLoader.getResource(path);
File file=new File(resource.getFile());

Class clazz=classLoader.loadClass("com.zhouyu.service");

断点调试resume，可以跳到下一个标记的断电代码，跳出内部框架代码